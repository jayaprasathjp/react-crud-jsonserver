{"version":3,"file":"browser.umd.js","sources":["../src/storage.ts","../src/err.ts","../src/compile.ts","../src/compile-string.ts","../src/utils.ts","../src/config.ts","../src/parse.ts","../src/render.ts","../src/core.ts","../src/browser.ts"],"sourcesContent":["/**\n * Handles storage and accessing of values\n *\n * In this case, we use it to store compiled template functions\n * Indexed by their `name` or `filename`\n */\n\nexport class Cacher<T> {\n  constructor(private cache: Record<string, T>) {}\n  define(key: string, val: T): void {\n    this.cache[key] = val;\n  }\n  get(key: string): T {\n    return this.cache[key];\n  }\n  remove(key: string): void {\n    delete this.cache[key];\n  }\n  reset(): void {\n    this.cache = {};\n  }\n  load(cacheObj: Record<string, T>): void {\n    this.cache = { ...this.cache, ...cacheObj };\n  }\n}\n","export class EtaError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"Eta Error\";\n  }\n}\n\n/**\n * Throws an EtaError with a nicely formatted error and message showing where in the template the error occurred.\n */\n\nexport function ParseErr(message: string, str: string, indx: number): void {\n  const whitespace = str.slice(0, indx).split(/\\n/);\n\n  const lineNo = whitespace.length;\n  const colNo = whitespace[lineNo - 1].length + 1;\n  message +=\n    \" at line \" +\n    lineNo +\n    \" col \" +\n    colNo +\n    \":\\n\\n\" +\n    \"  \" +\n    str.split(/\\n/)[lineNo - 1] +\n    \"\\n\" +\n    \"  \" +\n    Array(colNo).join(\" \") +\n    \"^\";\n  throw new EtaError(message);\n}\n\nexport function RuntimeErr(originalError: Error, str: string, lineNo: number, path: string): void {\n  // code gratefully taken from https://github.com/mde/ejs and adapted\n\n  const lines = str.split(\"\\n\");\n  const start = Math.max(lineNo - 3, 0);\n  const end = Math.min(lines.length, lineNo + 3);\n  const filename = path;\n  // Error context\n  const context = lines\n    .slice(start, end)\n    .map(function (line, i) {\n      const curr = i + start + 1;\n      return (curr == lineNo ? \" >> \" : \"    \") + curr + \"| \" + line;\n    })\n    .join(\"\\n\");\n\n  const header = filename ? filename + \":\" + lineNo + \"\\n\" : \"line \" + lineNo + \"\\n\";\n\n  const err = new EtaError(header + context + \"\\n\\n\" + originalError.message);\n\n  err.name = originalError.name; // the original name (e.g. ReferenceError) may be useful\n\n  throw err;\n}\n","import { EtaError } from \"./err.ts\";\n\n/* TYPES */\nimport type { Eta } from \"./core.ts\";\nimport type { EtaConfig, Options } from \"./config.ts\";\n\nexport type TemplateFunction = (this: Eta, data?: object, options?: Partial<Options>) => string;\n/* END TYPES */\n\n/* istanbul ignore next */\nconst AsyncFunction = async function () {}.constructor; // eslint-disable-line @typescript-eslint/no-empty-function\n\n/**\n * Takes a template string and returns a template function that can be called with (data, config)\n *\n * @param str - The template string\n * @param config - A custom configuration object (optional)\n */\n\nexport function compile(this: Eta, str: string, options?: Partial<Options>): TemplateFunction {\n  const config: EtaConfig = this.config;\n\n  /* ASYNC HANDLING */\n  // code gratefully taken from https://github.com/mde/ejs and adapted\n  const ctor = options && options.async ? (AsyncFunction as FunctionConstructor) : Function;\n  /* END ASYNC HANDLING */\n\n  try {\n    return new ctor(\n      config.varName,\n      \"options\",\n      this.compileToString.call(this, str, options)\n    ) as TemplateFunction; // eslint-disable-line no-new-func\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      throw new EtaError(\n        \"Bad template syntax\\n\\n\" +\n          e.message +\n          \"\\n\" +\n          Array(e.message.length + 1).join(\"=\") +\n          \"\\n\" +\n          this.compileToString.call(this, str, options) +\n          \"\\n\" // This will put an extra newline before the callstack for extra readability\n      );\n    } else {\n      throw e;\n    }\n  }\n}\n","/* TYPES */\n\nimport type { Options } from \"./config.ts\";\nimport type { AstObject } from \"./parse.ts\";\nimport type { Eta } from \"./core.ts\";\n\n/* END TYPES */\n\n/**\n * Compiles a template string to a function string. Most often users just use `compile()`, which calls `compileToString` and creates a new function using the result\n */\n\nexport function compileToString(this: Eta, str: string, options?: Partial<Options>): string {\n  const config = this.config;\n  const isAsync = options && options.async;\n\n  const compileBody = this.compileBody;\n\n  const buffer: Array<AstObject> = this.parse.call(this, str);\n\n  // note: when the include function passes through options, the only parameter that matters is the filepath parameter\n  let res = `${config.functionHeader}\nlet include = (template, data) => this.render(template, data, options);\nlet includeAsync = (template, data) => this.renderAsync(template, data, options);\n\nlet __eta = {res: \"\", e: this.config.escapeFunction, f: this.config.filterFunction${\n    config.debug\n      ? ', line: 1, templateStr: \"' +\n        str.replace(/\\\\|\"/g, \"\\\\$&\").replace(/\\r\\n|\\n|\\r/g, \"\\\\n\") +\n        '\"'\n      : \"\"\n  }};\n\nfunction layout(path, data) {\n  __eta.layout = path;\n  __eta.layoutData = data;\n}${config.debug ? \"try {\" : \"\"}${config.useWith ? \"with(\" + config.varName + \"||{}){\" : \"\"}\n\n${compileBody.call(this, buffer)}\nif (__eta.layout) {\n  __eta.res = ${isAsync ? \"await includeAsync\" : \"include\"} (__eta.layout, {...${\n    config.varName\n  }, body: __eta.res, ...__eta.layoutData});\n}\n${config.useWith ? \"}\" : \"\"}${\n    config.debug\n      ? \"} catch (e) { this.RuntimeErr(e, __eta.templateStr, __eta.line, options.filepath) }\"\n      : \"\"\n  }\nreturn __eta.res;\n`;\n\n  if (config.plugins) {\n    for (let i = 0; i < config.plugins.length; i++) {\n      const plugin = config.plugins[i];\n      if (plugin.processFnString) {\n        res = plugin.processFnString(res, config);\n      }\n    }\n  }\n\n  return res;\n}\n\n/**\n * Loops through the AST generated by `parse` and transform each item into JS calls\n *\n * **Example**\n *\n * ```js\n * let templateAST = ['Hi ', { val: 'it.name', t: 'i' }]\n * compileBody.call(Eta, templateAST)\n * // => \"__eta.res+='Hi '\\n__eta.res+=__eta.e(it.name)\\n\"\n * ```\n */\n\nexport function compileBody(this: Eta, buff: Array<AstObject>) {\n  const config = this.config;\n\n  let i = 0;\n  const buffLength = buff.length;\n  let returnStr = \"\";\n\n  for (i; i < buffLength; i++) {\n    const currentBlock = buff[i];\n    if (typeof currentBlock === \"string\") {\n      const str = currentBlock;\n\n      // we know string exists\n      returnStr += \"__eta.res+='\" + str + \"'\\n\";\n    } else {\n      const type = currentBlock.t; // \"r\", \"e\", or \"i\"\n      let content = currentBlock.val || \"\";\n\n      if (config.debug) returnStr += \"__eta.line=\" + currentBlock.lineNo + \"\\n\";\n\n      if (type === \"r\") {\n        // raw\n\n        if (config.autoFilter) {\n          content = \"__eta.f(\" + content + \")\";\n        }\n\n        returnStr += \"__eta.res+=\" + content + \"\\n\";\n      } else if (type === \"i\") {\n        // interpolate\n\n        if (config.autoFilter) {\n          content = \"__eta.f(\" + content + \")\";\n        }\n\n        if (config.autoEscape) {\n          content = \"__eta.e(\" + content + \")\";\n        }\n\n        returnStr += \"__eta.res+=\" + content + \"\\n\";\n      } else if (type === \"e\") {\n        // execute\n        returnStr += content + \"\\n\";\n      }\n    }\n  }\n\n  return returnStr;\n}\n","import type { EtaConfig } from \"./config.ts\";\n\n/**\n * Takes a string within a template and trims it, based on the preceding tag's whitespace control and `config.autoTrim`\n */\n\nexport function trimWS(\n  str: string,\n  config: EtaConfig,\n  wsLeft: string | false,\n  wsRight?: string | false\n): string {\n  let leftTrim;\n  let rightTrim;\n\n  if (Array.isArray(config.autoTrim)) {\n    // Slightly confusing,\n    // but _}} will trim the left side of the following string\n    leftTrim = config.autoTrim[1];\n    rightTrim = config.autoTrim[0];\n  } else {\n    leftTrim = rightTrim = config.autoTrim;\n  }\n\n  if (wsLeft || wsLeft === false) {\n    leftTrim = wsLeft;\n  }\n\n  if (wsRight || wsRight === false) {\n    rightTrim = wsRight;\n  }\n\n  if (!rightTrim && !leftTrim) {\n    return str;\n  }\n\n  if (leftTrim === \"slurp\" && rightTrim === \"slurp\") {\n    return str.trim();\n  }\n\n  if (leftTrim === \"_\" || leftTrim === \"slurp\") {\n    // full slurp\n    str = str.trimStart();\n  } else if (leftTrim === \"-\" || leftTrim === \"nl\") {\n    // nl trim\n    str = str.replace(/^(?:\\r\\n|\\n|\\r)/, \"\");\n  }\n\n  if (rightTrim === \"_\" || rightTrim === \"slurp\") {\n    // full slurp\n    str = str.trimEnd();\n  } else if (rightTrim === \"-\" || rightTrim === \"nl\") {\n    // nl trim\n    str = str.replace(/(?:\\r\\n|\\n|\\r)$/, \"\");\n  }\n\n  return str;\n}\n\n/**\n * A map of special HTML characters to their XML-escaped equivalents\n */\n\nconst escMap: { [key: string]: string } = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\",\n};\n\nfunction replaceChar(s: string): string {\n  return escMap[s];\n}\n\n/**\n * XML-escapes an input value after converting it to a string\n *\n * @param str - Input value (usually a string)\n * @returns XML-escaped string\n */\n\nexport function XMLEscape(str: unknown): string {\n  // To deal with XSS. Based on Escape implementations of Mustache.JS and Marko, then customized.\n  const newStr = String(str);\n  if (/[&<>\"']/.test(newStr)) {\n    return newStr.replace(/[&<>\"']/g, replaceChar);\n  } else {\n    return newStr;\n  }\n}\n","import { XMLEscape } from \"./utils.ts\";\n\n/* TYPES */\n\ntype trimConfig = \"nl\" | \"slurp\" | false;\n\nexport interface Options {\n  /** Compile to async function */\n  async?: boolean;\n\n  /** Absolute path to template file */\n  filepath?: string;\n}\n\nexport interface EtaConfig {\n  /** Whether or not to automatically XML-escape interpolations. Default true */\n  autoEscape: boolean;\n\n  /** Apply a filter function defined on the class to every interpolation or raw interpolation */\n  autoFilter: boolean;\n\n  /** Configure automatic whitespace trimming. Default `[false, 'nl']` */\n  autoTrim: trimConfig | [trimConfig, trimConfig];\n\n  /** Whether or not to cache templates if `name` or `filename` is passed */\n  cache: boolean;\n\n  /** Holds cache of resolved filepaths. Set to `false` to disable. */\n  cacheFilepaths: boolean;\n\n  /** Whether to pretty-format error messages (introduces runtime penalties) */\n  debug: boolean;\n\n  /** Function to XML-sanitize interpolations */\n  escapeFunction: (str: unknown) => string;\n\n  /** Function applied to all interpolations when autoFilter is true */\n  filterFunction: (val: unknown) => string;\n\n  /** Raw JS code inserted in the template function. Useful for declaring global variables for user templates */\n  functionHeader: string;\n\n  /** Parsing options */\n  parse: {\n    /** Which prefix to use for evaluation. Default `\"\"`, does not support `\"-\"` or `\"_\"` */\n    exec: string;\n\n    /** Which prefix to use for interpolation. Default `\"=\"`, does not support `\"-\"` or `\"_\"` */\n    interpolate: string;\n\n    /** Which prefix to use for raw interpolation. Default `\"~\"`, does not support `\"-\"` or `\"_\"` */\n    raw: string;\n  };\n\n  /** Array of plugins */\n  plugins: Array<{ processFnString?: Function; processAST?: Function; processTemplate?: Function }>;\n\n  /** Remove all safe-to-remove whitespace */\n  rmWhitespace: boolean;\n\n  /** Delimiters: by default `['<%', '%>']` */\n  tags: [string, string];\n\n  /** Make data available on the global object instead of varName */\n  useWith: boolean;\n\n  /** Name of the data object. Default `it` */\n  varName: string;\n\n  /** Directory that contains templates */\n  views?: string;\n\n  /** Control template file extension defaults. Default `.eta` */\n  defaultExtension?: string;\n}\n\n/* END TYPES */\n\n/** Eta's base (global) configuration */\nconst defaultConfig: EtaConfig = {\n  autoEscape: true,\n  autoFilter: false,\n  autoTrim: [false, \"nl\"],\n  cache: false,\n  cacheFilepaths: true,\n  debug: false,\n  escapeFunction: XMLEscape,\n  // default filter function (not used unless enables) just stringifies the input\n  filterFunction: (val) => String(val),\n  functionHeader: \"\",\n  parse: {\n    exec: \"\",\n    interpolate: \"=\",\n    raw: \"~\",\n  },\n  plugins: [],\n  rmWhitespace: false,\n  tags: [\"<%\", \"%>\"],\n  useWith: false,\n  varName: \"it\",\n  defaultExtension: \".eta\",\n};\n\nexport { defaultConfig };\n","import { ParseErr } from \"./err.ts\";\nimport { trimWS } from \"./utils.ts\";\n\n/* TYPES */\n\nimport type { Eta } from \"./core.ts\";\n\nexport type TagType = \"r\" | \"e\" | \"i\" | \"\";\n\nexport interface TemplateObject {\n  t: TagType;\n  val: string;\n  lineNo?: number;\n}\n\nexport type AstObject = string | TemplateObject;\n\n/* END TYPES */\n\nconst templateLitReg = /`(?:\\\\[\\s\\S]|\\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})*}|(?!\\${)[^\\\\`])*`/g;\n\nconst singleQuoteReg = /'(?:\\\\[\\s\\w\"'\\\\`]|[^\\n\\r'\\\\])*?'/g;\n\nconst doubleQuoteReg = /\"(?:\\\\[\\s\\w\"'\\\\`]|[^\\n\\r\"\\\\])*?\"/g;\n\n/** Escape special regular expression characters inside a string */\n\nfunction escapeRegExp(string: string) {\n  // From MDN\n  return string.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n}\n\nfunction getLineNo(str: string, index: number) {\n  return str.slice(0, index).split(\"\\n\").length;\n}\n\nexport function parse(this: Eta, str: string): Array<AstObject> {\n  const config = this.config;\n\n  let buffer: Array<AstObject> = [];\n  let trimLeftOfNextStr: string | false = false;\n  let lastIndex = 0;\n  const parseOptions = config.parse;\n\n  if (config.plugins) {\n    for (let i = 0; i < config.plugins.length; i++) {\n      const plugin = config.plugins[i];\n      if (plugin.processTemplate) {\n        str = plugin.processTemplate(str, config);\n      }\n    }\n  }\n\n  /* Adding for EJS compatibility */\n  if (config.rmWhitespace) {\n    // Code taken directly from EJS\n    // Have to use two separate replaces here as `^` and `$` operators don't\n    // work well with `\\r` and empty lines don't work well with the `m` flag.\n    // Essentially, this replaces the whitespace at the beginning and end of\n    // each line and removes multiple newlines.\n    str = str.replace(/[\\r\\n]+/g, \"\\n\").replace(/^\\s+|\\s+$/gm, \"\");\n  }\n  /* End rmWhitespace option */\n\n  templateLitReg.lastIndex = 0;\n  singleQuoteReg.lastIndex = 0;\n  doubleQuoteReg.lastIndex = 0;\n\n  function pushString(strng: string, shouldTrimRightOfString?: string | false) {\n    if (strng) {\n      // if string is truthy it must be of type 'string'\n\n      strng = trimWS(\n        strng,\n        config,\n        trimLeftOfNextStr, // this will only be false on the first str, the next ones will be null or undefined\n        shouldTrimRightOfString\n      );\n\n      if (strng) {\n        // replace \\ with \\\\, ' with \\'\n        // we're going to convert all CRLF to LF so it doesn't take more than one replace\n\n        strng = strng.replace(/\\\\|'/g, \"\\\\$&\").replace(/\\r\\n|\\n|\\r/g, \"\\\\n\");\n\n        buffer.push(strng);\n      }\n    }\n  }\n\n  const prefixes = [parseOptions.exec, parseOptions.interpolate, parseOptions.raw].reduce(function (\n    accumulator,\n    prefix\n  ) {\n    if (accumulator && prefix) {\n      return accumulator + \"|\" + escapeRegExp(prefix);\n    } else if (prefix) {\n      // accumulator is falsy\n      return escapeRegExp(prefix);\n    } else {\n      // prefix and accumulator are both falsy\n      return accumulator;\n    }\n  },\n  \"\");\n\n  const parseOpenReg = new RegExp(\n    escapeRegExp(config.tags[0]) + \"(-|_)?\\\\s*(\" + prefixes + \")?\\\\s*\",\n    \"g\"\n  );\n\n  const parseCloseReg = new RegExp(\n    \"'|\\\"|`|\\\\/\\\\*|(\\\\s*(-|_)?\" + escapeRegExp(config.tags[1]) + \")\",\n    \"g\"\n  );\n\n  let m;\n\n  while ((m = parseOpenReg.exec(str))) {\n    const precedingString = str.slice(lastIndex, m.index);\n\n    lastIndex = m[0].length + m.index;\n\n    const wsLeft = m[1];\n    const prefix = m[2] || \"\"; // by default either ~, =, or empty\n\n    pushString(precedingString, wsLeft);\n\n    parseCloseReg.lastIndex = lastIndex;\n    let closeTag;\n    let currentObj: AstObject | false = false;\n\n    while ((closeTag = parseCloseReg.exec(str))) {\n      if (closeTag[1]) {\n        const content = str.slice(lastIndex, closeTag.index);\n\n        parseOpenReg.lastIndex = lastIndex = parseCloseReg.lastIndex;\n\n        trimLeftOfNextStr = closeTag[2];\n\n        const currentType: TagType =\n          prefix === parseOptions.exec\n            ? \"e\"\n            : prefix === parseOptions.raw\n            ? \"r\"\n            : prefix === parseOptions.interpolate\n            ? \"i\"\n            : \"\";\n\n        currentObj = { t: currentType, val: content };\n        break;\n      } else {\n        const char = closeTag[0];\n        if (char === \"/*\") {\n          const commentCloseInd = str.indexOf(\"*/\", parseCloseReg.lastIndex);\n\n          if (commentCloseInd === -1) {\n            ParseErr(\"unclosed comment\", str, closeTag.index);\n          }\n          parseCloseReg.lastIndex = commentCloseInd;\n        } else if (char === \"'\") {\n          singleQuoteReg.lastIndex = closeTag.index;\n\n          const singleQuoteMatch = singleQuoteReg.exec(str);\n          if (singleQuoteMatch) {\n            parseCloseReg.lastIndex = singleQuoteReg.lastIndex;\n          } else {\n            ParseErr(\"unclosed string\", str, closeTag.index);\n          }\n        } else if (char === '\"') {\n          doubleQuoteReg.lastIndex = closeTag.index;\n          const doubleQuoteMatch = doubleQuoteReg.exec(str);\n\n          if (doubleQuoteMatch) {\n            parseCloseReg.lastIndex = doubleQuoteReg.lastIndex;\n          } else {\n            ParseErr(\"unclosed string\", str, closeTag.index);\n          }\n        } else if (char === \"`\") {\n          templateLitReg.lastIndex = closeTag.index;\n          const templateLitMatch = templateLitReg.exec(str);\n          if (templateLitMatch) {\n            parseCloseReg.lastIndex = templateLitReg.lastIndex;\n          } else {\n            ParseErr(\"unclosed string\", str, closeTag.index);\n          }\n        }\n      }\n    }\n    if (currentObj) {\n      if (config.debug) {\n        currentObj.lineNo = getLineNo(str, m.index);\n      }\n      buffer.push(currentObj);\n    } else {\n      ParseErr(\"unclosed tag\", str, m.index);\n    }\n  }\n\n  pushString(str.slice(lastIndex, str.length), false);\n\n  if (config.plugins) {\n    for (let i = 0; i < config.plugins.length; i++) {\n      const plugin = config.plugins[i];\n      if (plugin.processAST) {\n        buffer = plugin.processAST(buffer, config);\n      }\n    }\n  }\n\n  return buffer;\n}\n","import { EtaError } from \"./err.ts\";\n\n/* TYPES */\nimport type { Options } from \"./config.ts\";\nimport type { TemplateFunction } from \"./compile.ts\";\nimport type { Eta } from \"./core.ts\";\n/* END TYPES */\n\nfunction handleCache(this: Eta, template: string, options: Partial<Options>): TemplateFunction {\n  const templateStore = options && options.async ? this.templatesAsync : this.templatesSync;\n\n  if (this.resolvePath && this.readFile && !template.startsWith(\"@\")) {\n    const templatePath = options.filepath as string;\n\n    const cachedTemplate = templateStore.get(templatePath);\n\n    if (this.config.cache && cachedTemplate) {\n      return cachedTemplate;\n    } else {\n      const templateString = this.readFile(templatePath);\n\n      const templateFn = this.compile(templateString, options);\n\n      if (this.config.cache) templateStore.define(templatePath, templateFn);\n\n      return templateFn;\n    }\n  } else {\n    const cachedTemplate = templateStore.get(template);\n\n    if (cachedTemplate) {\n      return cachedTemplate;\n    } else {\n      throw new EtaError(\"Failed to get template '\" + template + \"'\");\n    }\n  }\n}\n\nexport function render(\n  this: Eta,\n  template: string | TemplateFunction, // template name or template function\n  data: object,\n  meta?: { filepath: string }\n): string {\n  let templateFn: TemplateFunction;\n  const options = { ...meta, async: false };\n\n  if (typeof template === \"string\") {\n    if (this.resolvePath && this.readFile && !template.startsWith(\"@\")) {\n      options.filepath = this.resolvePath(template, options);\n    }\n\n    templateFn = handleCache.call(this, template, options);\n  } else {\n    templateFn = template;\n  }\n\n  const res = templateFn.call(this, data, options);\n\n  return res;\n}\n\nexport function renderAsync(\n  this: Eta,\n  template: string | TemplateFunction, // template name or template function\n  data: object,\n  meta?: { filepath: string }\n): Promise<string> {\n  let templateFn: TemplateFunction;\n  const options = { ...meta, async: true };\n\n  if (typeof template === \"string\") {\n    if (this.resolvePath && this.readFile && !template.startsWith(\"@\")) {\n      options.filepath = this.resolvePath(template, options);\n    }\n\n    templateFn = handleCache.call(this, template, options);\n  } else {\n    templateFn = template;\n  }\n\n  const res = templateFn.call(this, data, options);\n\n  // Return a promise\n  return Promise.resolve(res);\n}\n\nexport function renderString(this: Eta, template: string, data: object): string {\n  const templateFn = this.compile(template, { async: false });\n\n  return render.call(this, templateFn, data);\n}\n\nexport function renderStringAsync(this: Eta, template: string, data: object): Promise<string> {\n  const templateFn = this.compile(template, { async: true });\n\n  return renderAsync.call(this, templateFn, data);\n}\n","import { Cacher } from \"./storage.ts\";\nimport { compile } from \"./compile.ts\";\nimport { compileToString, compileBody } from \"./compile-string.ts\";\nimport { defaultConfig } from \"./config.ts\";\nimport { parse } from \"./parse.ts\";\nimport { render, renderAsync, renderString, renderStringAsync } from \"./render.ts\";\nimport { RuntimeErr, EtaError } from \"./err.ts\";\nimport { TemplateFunction } from \"./compile.ts\";\n\n/* TYPES */\nimport type { EtaConfig, Options } from \"./config.ts\";\n/* END TYPES */\n\nexport class Eta {\n  constructor(customConfig?: Partial<EtaConfig>) {\n    if (customConfig) {\n      this.config = { ...defaultConfig, ...customConfig };\n    } else {\n      this.config = { ...defaultConfig };\n    }\n  }\n\n  config: EtaConfig;\n\n  RuntimeErr = RuntimeErr;\n\n  compile = compile;\n  compileToString = compileToString;\n  compileBody = compileBody;\n  parse = parse;\n  render = render;\n  renderAsync = renderAsync;\n  renderString = renderString;\n  renderStringAsync = renderStringAsync;\n\n  filepathCache: Record<string, string> = {};\n  templatesSync = new Cacher<TemplateFunction>({});\n  templatesAsync = new Cacher<TemplateFunction>({});\n\n  // resolvePath takes a relative path from the \"views\" directory\n  resolvePath: null | ((this: Eta, template: string, options?: Partial<Options>) => string) = null;\n  readFile: null | ((this: Eta, path: string) => string) = null;\n\n  // METHODS\n\n  configure(customConfig: Partial<EtaConfig>) {\n    this.config = { ...this.config, ...customConfig };\n  }\n\n  withConfig(customConfig: Partial<EtaConfig>) {\n    return { ...this, config: { ...this.config, ...customConfig } };\n  }\n\n  loadTemplate(\n    name: string,\n    template: string | TemplateFunction, // template string or template function\n    options?: { async: boolean }\n  ): void {\n    if (typeof template === \"string\") {\n      const templates = options && options.async ? this.templatesAsync : this.templatesSync;\n\n      templates.define(name, this.compile(template, options));\n    } else {\n      let templates = this.templatesSync;\n\n      if (template.constructor.name === \"AsyncFunction\" || (options && options.async)) {\n        templates = this.templatesAsync;\n      }\n\n      templates.define(name, template);\n    }\n  }\n}\n\n// for instance checking against thrown errors\nexport { EtaError };\n","import { Eta as EtaCore } from \"./core.ts\";\n\nexport class Eta extends EtaCore {}\n"],"names":["Cacher","cache","this","_proto","prototype","define","key","val","get","remove","reset","load","cacheObj","_extends","EtaError","_Error","message","_this","call","name","_inheritsLoose","_wrapNativeSuper","Error","ParseErr","str","indx","whitespace","slice","split","lineNo","length","colNo","Array","join","RuntimeErr","originalError","path","lines","start","Math","max","end","min","filename","context","map","line","i","curr","err","AsyncFunction","Promise","resolve","constructor","compile","options","config","ctor","async","Function","varName","compileToString","e","SyntaxError","isAsync","compileBody","buffer","parse","res","functionHeader","debug","replace","useWith","plugins","plugin","processFnString","buff","buffLength","returnStr","currentBlock","type","t","content","autoFilter","autoEscape","escMap","replaceChar","s","defaultConfig","autoTrim","cacheFilepaths","escapeFunction","newStr","String","test","filterFunction","exec","interpolate","raw","rmWhitespace","tags","defaultExtension","templateLitReg","singleQuoteReg","doubleQuoteReg","escapeRegExp","string","getLineNo","index","trimLeftOfNextStr","lastIndex","parseOptions","processTemplate","pushString","strng","shouldTrimRightOfString","wsLeft","wsRight","leftTrim","rightTrim","isArray","trim","trimStart","trimEnd","trimWS","push","m","prefixes","reduce","accumulator","prefix","parseOpenReg","RegExp","parseCloseReg","precedingString","closeTag","currentObj","char","commentCloseInd","indexOf","processAST","handleCache","template","templateStore","templatesAsync","templatesSync","resolvePath","readFile","startsWith","templatePath","filepath","cachedTemplate","templateString","templateFn","render","data","meta","renderAsync","renderString","renderStringAsync","Eta","customConfig","filepathCache","configure","withConfig","loadTemplate","templates","_EtaCore","apply","arguments","EtaCore"],"mappings":"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"}